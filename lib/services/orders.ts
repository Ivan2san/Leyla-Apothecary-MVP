import { createClient } from '@/lib/supabase/server'

export interface CreateOrderData {
  userId: string
  items: Array<{
    productId: string
    quantity: number
    price: number
  }>
  shippingAddress: {
    fullName: string
    addressLine1: string
    addressLine2?: string
    city: string
    state: string
    zipCode: string
    country: string
    phone: string
  }
  subtotal: number
  shippingCost: number
  tax: number
  totalAmount: number
}

export class OrderService {
  static async createOrder(data: CreateOrderData) {
    const supabase = await createClient()

    // STEP 1: Fetch and validate all products with their current prices
    const productIds = data.items.map((item) => item.productId)
    const { data: products, error: productsError } = await supabase
      .from('products')
      .select('id, name, price, stock_quantity, is_active')
      .in('id', productIds)

    if (productsError) {
      throw new Error(`Failed to fetch products: ${productsError.message}`)
    }

    if (!products || products.length !== data.items.length) {
      throw new Error('Some products not found or inactive')
    }

    // STEP 2: Validate stock availability and recalculate prices server-side
    let calculatedSubtotal = 0
    const validatedItems: Array<{
      product_id: string
      quantity: number
      price: number
      product_snapshot: any
    }> = []

    for (const item of data.items) {
      const product = products.find((p) => p.id === item.productId)

      if (!product) {
        throw new Error(`Product ${item.productId} not found`)
      }

      if (!product.is_active) {
        throw new Error(`Product ${product.name} is no longer available`)
      }

      if (product.stock_quantity < item.quantity) {
        throw new Error(
          `Insufficient stock for ${product.name}. Available: ${product.stock_quantity}, Requested: ${item.quantity}`
        )
      }

      // Use SERVER price, not client-provided price
      const serverPrice = product.price
      const lineTotal = serverPrice * item.quantity
      calculatedSubtotal += lineTotal

      validatedItems.push({
        product_id: item.productId,
        quantity: item.quantity,
        price: serverPrice, // Server-validated price
        product_snapshot: {
          name: product.name,
          price: serverPrice,
        },
      })
    }

    // STEP 3: Recalculate shipping, tax, and total server-side
    const shippingCost = calculatedSubtotal >= 50 ? 0 : 5.99
    const tax = calculatedSubtotal * 0.08 // 8% tax rate
    const totalAmount = calculatedSubtotal + shippingCost + tax

    // STEP 4: Validate against client-provided values (for debugging/logging)
    const priceDifference = Math.abs(totalAmount - data.totalAmount)
    if (priceDifference > 0.01) {
      console.warn(
        `Price mismatch: Client sent ${data.totalAmount}, Server calculated ${totalAmount}`
      )
      // Don't throw error, just use server-calculated values
    }

    // STEP 5: Create the order with SERVER-CALCULATED values
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        user_id: data.userId,
        status: 'pending',
        subtotal: calculatedSubtotal,    // Server-calculated
        shipping: shippingCost,          // Server-calculated
        tax: tax,                        // Server-calculated
        total: totalAmount,              // Server-calculated
        shipping_address: data.shippingAddress,
        // order_number will be auto-generated by database trigger
      })
      .select()
      .single()

    if (orderError) {
      throw new Error(`Failed to create order: ${orderError.message}`)
    }

    // STEP 6: Create order items
    const orderItems = validatedItems.map((item) => ({
      ...item,
      order_id: order.id,
    }))

    const { error: itemsError } = await supabase
      .from('order_items')
      .insert(orderItems)

    if (itemsError) {
      // Rollback: delete the order if items creation fails
      await supabase.from('orders').delete().eq('id', order.id)
      throw new Error(`Failed to create order items: ${itemsError.message}`)
    }

    // STEP 7: Decrement stock for each product
    for (const item of validatedItems) {
      const product = products.find((p) => p.id === item.product_id)!
      const newStock = product.stock_quantity - item.quantity

      const { error: stockError } = await supabase
        .from('products')
        .update({ stock_quantity: newStock })
        .eq('id', item.product_id)

      if (stockError) {
        console.error(`Failed to update stock for product ${item.product_id}:`, stockError)
        // Continue anyway - this is a non-critical error
        // TODO: Implement proper inventory management with transactions
      }
    }

    return order
  }

  static async getOrder(orderId: string) {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('orders')
      .select('*, order_items(*, products(*))')
      .eq('id', orderId)
      .single()

    if (error) {
      throw new Error(`Failed to get order: ${error.message}`)
    }

    return data
  }

  static async getUserOrders(userId: string) {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('orders')
      .select('*, order_items(*, products(*))')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })

    if (error) {
      throw new Error(`Failed to get user orders: ${error.message}`)
    }

    return data
  }

  static async updateOrderStatus(
    orderId: string,
    status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled'
  ) {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('orders')
      .update({ status })
      .eq('id', orderId)
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to update order status: ${error.message}`)
    }

    return data
  }
}
